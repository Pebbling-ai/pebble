# 
# |---------------------------------------------------------|
# |                                                         |
# |                 Give Feedback / Get Help                |
# | https://github.com/Pebbling-ai/pebble/issues/new/choose |
# |                                                         |
# |---------------------------------------------------------|
#
#  Thank you users! We ‚ù§Ô∏è you! - üêß

"""
Pebbling Protocol Type Definitions.

This module contains all the protocol data models used for communication between
agents and the Pebbling framework.
"""
from __future__ import annotations as _annotations

from enum import Enum
from typing import Annotated, Any, Generic, Literal, TypeVar, Union
from uuid import UUID

from pydantic import Discriminator, Field, RootModel
from pydantic.alias_generators import to_camel
from typing_extensions import Required, NotRequired, TypedDict, TypeAlias

from pebbling.protocol._base import PebblingProtocolBaseModel

#-----------------------------------------------------------------------------
# Base Types and Enums
#-----------------------------------------------------------------------------

Role: TypeAlias = Literal['agent', 'user']

TaskState: TypeAlias = Literal[
    'submitted',
    'working', 
    'input-required',
    'completed',
    'canceled',
    'failed',
    'rejected',
    'auth-required',
    'unknown',
    'trust-verification-required',
    'pending',
    'suspended',
    'resumed',
    'negotiation-bid-submitted',
    'negotiation-bid-lost',
    'negotiation-bid-won',
]


ErrorCode: TypeAlias = Literal[
    "server_error",
    "invalid_input", 
    "not_found"
]


RunMode: TypeAlias = Literal[
    "sync",        # Synchronous execution, wait for complete response
    "async",       # Asynchronous execution, don't wait for response  
    "stream"       # Streaming execution, receive partial results
]

NegotiationStatus: TypeAlias = Literal[
    "proposed",
    "accepted",
    "rejected",
    "countered"
]

NegotiationSessionStatus: TypeAlias = Literal[
    "initiated",
    "ongoing",
    "completed",
    "rejected"
]


#-----------------------------------------------------------------------------
# Content & Message Parts
#-----------------------------------------------------------------------------

@pydantic.with_config({'alias_generator': to_camel})
class TextPart(PebblingProtocolBaseModel):
    """Represents a text segment within parts."""
    
    kind: Required[Literal['text']]
    metadata: NotRequired[dict[str, Any]]
    content: Required[str]

@pydantic.with_config({'alias_generator': to_camel})
class FileWithBytes(PebblingProtocolBaseModel):
    """File representation with binary content."""
    
    bytes: Required[str]
    mimeType: NotRequired[str]
    name: NotRequired[str]

@pydantic.with_config({'alias_generator': to_camel})
class FileWithUri(FileWithBytes):
    """File representation with URI reference."""
    
    uri: Required[str]

@pydantic.with_config({'alias_generator': to_camel})
class FilePart(TextPart):
    """Represents a file part in a message."""
    
    kind: Required[Literal['file']]
    file: Required[FileWithBytes | FileWithUri]


@pydantic.with_config({'alias_generator': to_camel})
class DataPart(TextPart):
    """Represents a structured data part in a message."""
    
    kind: Required[Literal['data']]
    data: Required[dict[str, Any]]


Part = Annotated[RootModel[TextPart | FilePart | DataPart], Field(discriminator='kind')]


#-----------------------------------------------------------------------------
# Artifacts
#-----------------------------------------------------------------------------

@pydantic.with_config({'alias_generator': to_camel})
class Artifact(PebblingProtocolBaseModel):
    """Represents the final output generated by an agent after completing a task.

    Artifacts are immutable data structures that contain the results of agent execution.
    They can contain multiple parts (text, files, structured data) and are uniquely 
    identified for tracking and retrieval.

    Key Properties:
    - Immutable: Once created, artifacts cannot be modified
    - Multi-part: Can contain text, files, and structured data
    - Streamable: Parts can be appended during streaming responses
    - Traceable: Each artifact has a unique ID for reference

    A single task may produce multiple artifacts when the output naturally
    separates into distinct deliverables (e.g., frontend + backend code).
    """
    
    artifact_id: Required[UUID] = Field(..., description="Unique identifier for the artifact")
    name: NotRequired[str]
    description: NotRequired[str]
    metadata: NotRequired[dict[str, Any]]
    parts: NotRequired[list[Part]]
    append: NotRequired[bool]
    last_chunk: NotRequired[bool]
    extra_data: NotRequired[dict[str, Any]]


@pydantic.with_config({'alias_generator': to_camel})
class Message(PebblingProtocolBaseModel):
    """Communication content exchanged between agents, users, and systems.

    Messages represent all non-result communication in the Pebbling protocol.
    Unlike Artifacts (which contain task outputs), Messages carry operational
    content like instructions, status updates, context, and metadata.

    Message Types:
    - User Instructions: Task requests with context and files
    - Agent Communication: Status updates, thoughts, coordination
    - System Messages: Errors, warnings, protocol information
    - Context Sharing: Background information, references, metadata

    Multi-part Structure:
    Messages can contain multiple parts to organize different content types:
    - Text parts for instructions or descriptions
    - File parts for context documents or references  
    - Data parts for structured metadata or parameters

    Flow Pattern:
    Client ‚Üí Message (request) ‚Üí Agent ‚Üí Message (status) ‚Üí Artifact (result)
    """

    contextId: Required[UUID]
    task_id: Required[UUID]
    reference_task_ids: NotRequired[list[UUID]]
    message_id: Required[UUID]
    kind: Required[Literal['message']]
    
    metadata: NotRequired[dict[str, Any]]
    parts: Required[list[Part]]
    role: Required[Role]
    extra_data: NotRequired[dict[str, Any]]


#-----------------------------------------------------------------------------
# Task
#-----------------------------------------------------------------------------

@pydantic.with_config({'alias_generator': to_camel})
class TaskStatus(PebblingProtocolBaseModel):
    """Status information for a task."""
    
    message: NotRequired[Message]
    state: Required[TaskState]
    timestamp: Required[str] = Field(
        examples=['2023-10-27T10:00:00Z'],
        description="ISO datetime value of when the status was updated."
    )


@pydantic.with_config({'alias_generator': to_camel})
class Task(PebblingProtocolBaseModel):
    """Stateful execution unit that coordinates client-agent interaction to achieve a goal.

    Tasks serve as the primary coordination mechanism in the Pebbling protocol,
    managing the complete lifecycle from request to completion. They maintain
    conversation history, track execution state, and collect generated artifacts.

    Core Responsibilities:
    - Message Exchange: Facilitate communication between clients and agents
    - State Management: Track task progress and execution status
    - Artifact Collection: Gather and organize agent-generated outputs
    - History Tracking: Maintain complete conversation and decision trail

    Task Lifecycle:
    1. Creation: Client initiates task with initial message/requirements
    2. Processing: Agent processes messages and updates status
    3. Communication: Bidirectional message exchange as needed
    4. Artifact Generation: Agent produces deliverable outputs
    5. Completion: Final status update and artifact delivery

    Key Properties:
    - Client-Initiated: Always created by clients, never by agents
    - Agent-Controlled: Status and progress determined by executing agent
    - Stateful: Maintains complete execution context and history
    - Traceable: Unique ID enables task tracking and reference

    Task Relationships:
    - Contains: Multiple messages (conversation history)
    - Produces: Multiple artifacts (execution results)
    - References: Other tasks via reference_task_ids for coordination
    - Belongs to: Specific context for session management
    """
    
    id: Required[UUID]
    contextId: Required[UUID]
    kind: Required[Literal['task']]
    status: Required[TaskStatus]

    artifacts: NotRequired[list[Artifact]]
    history: NotRequired[list[Message]]
    metadata: NotRequired[dict[str, Any]]

@pydantic.with_config({'alias_generator': to_camel})
class TaskStatusUpdateEvent(PebblingProtocolBaseModel):
    """Event for task status updates."""
    
    contextId: Required[UUID]
    final: Required[bool]
    kind: Required[Literal['status-update']]
    metadata: NotRequired[dict[str, Any]]
    status: Required[TaskStatus]
    taskId: Required[UUID]

@pydantic.with_config({'alias_generator': to_camel})
class TaskArtifactUpdateEvent(PebblingProtocolBaseModel):
    """Event for task artifact updates."""
    
    append: NotRequired[bool]
    artifact: Required[Artifact]
    contextId: Required[UUID]
    kind: Required[Literal['artifact-update']]
    lastChunk: NotRequired[bool]
    metadata: NotRequired[dict[str, Any]]
    taskId: Required[UUID]

@pydantic.with_config({'alias_generator': to_camel})
class TaskSendParams(PebblingProtocolBaseModel):
    """Internal parameters for task execution within the framework."""

    id: Required[UUID]
    context_id: Required[UUID]
    message: NotRequired[Message]
    history_length: NotRequired[int]
    metadata: NotRequired[dict[str, Any]]


@pydantic.with_config({'alias_generator': to_camel})
class TaskIdParams(PebblingProtocolBaseModel):
    """Parameters for task identification."""
    
    id: Required[UUID]
    metadata: NotRequired[dict[str, Any]]

@pydantic.with_config({'alias_generator': to_camel})
class TaskQueryParams(TaskIdParams):
    """Query parameters for a task."""

    history_length: NotRequired[int]

@pydantic.with_config({'alias_generator': to_camel})
class MessageSendConfiguration(PebblingProtocolBaseModel):
    """Configuration for message sending."""
    
    acceptedOutputModes: Required[list[str]]
    blocking: NotRequired[bool]
    historyLength: NotRequired[int]
    pushNotificationConfig: NotRequired[PushNotificationConfig]


@pydantic.with_config({'alias_generator': to_camel})
class MessageSendParams(PebblingProtocolBaseModel):
    """Parameters for sending messages."""
    
    configuration: Required[MessageSendConfiguration]
    message: Required[Message]
    metadata: NotRequired[dict[str, Any]]

#-----------------------------------------------------------------------------
# Agent-to-Agent Negotiation Models
#-----------------------------------------------------------------------------

@pydantic.with_config({'alias_generator': to_camel})
class NegotiationProposal(PebblingProtocolBaseModel):
    """Structured negotiation proposal exchanged between agents."""
    
    proposal_id: UUID = Field(..., description="Unique ID of this specific proposal")
    from_agent: UUID = Field(..., description="Agent ID initiating the proposal")
    to_agent: UUID = Field(..., description="Agent ID receiving the proposal")
    terms: Dict[str, Any] = Field(..., description="Negotiation terms (structured)")
    timestamp: int = Field(..., description="UNIX timestamp when the proposal was made")
    status: NegotiationStatus = Field(
        NegotiationStatus.proposed, 
        description="Status of this specific proposal"
    )

@pydantic.with_config({'alias_generator': to_camel})
class NegotiationSession(PebblingProtocolBaseModel):
    """Session details for agent-to-agent negotiations."""
    
    session_id: UUID = Field(..., description="Unique identifier for the negotiation session")
    status: NegotiationSessionStatus = Field(
        NegotiationSessionStatus.initiated,
        description="Current status of the negotiation"
    )
    participants: List[UUID] = Field(..., description="List of participating agent IDs")
    proposals: List[NegotiationProposal] = Field(
        default_factory=list,
        description="Array of negotiation proposals exchanged"
    )


#-----------------------------------------------------------------------------
# Payment Models
#-----------------------------------------------------------------------------

class PaymentAction(PebblingProtocolBaseModel):
    """Represents the possible payment actions."""
    
    action_type: Literal['submit', 'cancel', 'unknown'] = 'submit'
    amount: float = Field(..., description="The amount of the payment", examples=[10.0])
    currency: str = Field(..., description="ISO currency code clearly identified (e.g., USD)")
    billing_period: Literal["daily", "weekly", "monthly", "yearly", "one-time"] = Field(
        "one-time", 
        description="Billing frequency clearly defined if subscription-based"
    )


#-----------------------------------------------------------------------------
# JSON-RPC Error Types
#-----------------------------------------------------------------------------

CodeT = TypeVar('CodeT', bound=int)
MessageT = TypeVar('MessageT', bound=str)


class JSONRPCError(TypedDict, Generic[CodeT, MessageT]):
    """A JSON RPC error."""

    code: Required[CodeT]
    message: Required[MessageT]
    data: NotRequired[Any]


ResultT = TypeVar('ResultT')
ErrorT = TypeVar('ErrorT', bound=JSONRPCError[Any, Any])


class JSONRPCResponse(JSONRPCMessage, Generic[ResultT, ErrorT]):
    """A JSON RPC response."""

    result: NotRequired[ResultT]
    error: NotRequired[ErrorT]

JSONParseError = JSONRPCError[Literal[-32700], Literal['Failed to parse JSON payload. Please ensure the request body contains valid JSON syntax. See: https://www.jsonrpc.org/specification#error_object']]
InvalidRequestError = JSONRPCError[Literal[-32600], Literal['Request payload validation failed. The request structure does not conform to JSON-RPC 2.0 specification. See: https://www.jsonrpc.org/specification#request_object']]
MethodNotFoundError = JSONRPCError[Literal[-32601], Literal['The requested method is not available on this server. Please check the method name and try again. See API docs: /docs']]
InvalidParamsError = JSONRPCError[Literal[-32602], Literal['Invalid or missing parameters for the requested method. Please verify parameter types and required fields. See API docs: /docs']]
InternalError = JSONRPCError[Literal[-32603], Literal['An internal server error occurred while processing the request. Please try again or contact support if the issue persists. See: /health']]
TaskNotFoundError = JSONRPCError[Literal[-32001], Literal['The specified task ID was not found. The task may have been completed, canceled, or expired. Check task status: GET /tasks/{id}']]
TaskNotCancelableError = JSONRPCError[Literal[-32002], Literal['This task cannot be canceled in its current state. Tasks can only be canceled while pending or running. See task lifecycle: /docs/tasks']]
PushNotificationNotSupportedError = JSONRPCError[Literal[-32003], Literal['Push notifications are not supported by this server configuration. Please use polling to check task status. See: GET /tasks/{id}']]
UnsupportedOperationError = JSONRPCError[Literal[-32004], Literal['The requested operation is not supported by this agent or server configuration. See supported operations: /docs/capabilities']]
ContentTypeNotSupportedError = JSONRPCError[Literal[-32005], Literal['The content type in the request is not supported. Please use application/json or check supported content types. See: /docs/content-types']]
InvalidAgentResponseError = JSONRPCError[Literal[-32006], Literal['The agent returned an invalid or malformed response. This may indicate an agent configuration issue. See troubleshooting: /docs/troubleshooting']]


#-----------------------------------------------------------------------------
# JSON-RPC Request & Response Types
#-----------------------------------------------------------------------------

class JSONRPCErrorResponse(PebblingProtocolBaseModel):
    """JSON-RPC error response."""
    
    error: (
        JSONRPCError
        | JSONParseError
        | InvalidRequestError
        | MethodNotFoundError
        | InvalidParamsError
        | InternalError
        | TaskNotFoundError
        | TaskNotCancelableError
        | PushNotificationNotSupportedError
        | UnsupportedOperationError
        | ContentTypeNotSupportedError
        | InvalidAgentResponseError
    )
    id: str | int | None = None
    jsonrpc: Literal['2.0'] = '2.0'












# Response types
class SendMessageSuccessResponse(PebblingProtocolBaseModel):
    """Success response for sending a message."""
    
    id: UUID
    jsonrpc: Literal['2.0'] = '2.0'
    result: Task | Message


class SendStreamingMessageSuccessResponse(PebblingProtocolBaseModel):
    """Success response for sending a streaming message."""
    
    id: UUID
    jsonrpc: Literal['2.0'] = '2.0'
    result: Task | Message | TaskStatusUpdateEvent | TaskArtifactUpdateEvent


class GetTaskSuccessResponse(PebblingProtocolBaseModel):
    """Success response for getting a task."""
    
    id: UUID
    jsonrpc: Literal['2.0'] = '2.0'
    result: Task

@pydantic.with_config({'alias_generator': to_camel})
class CancelTaskSuccessResponse(PebblingProtocolBaseModel):
    """Success response for canceling a task."""
    
    id: UUID
    jsonrpc: Literal['2.0'] = '2.0'
    result: Task

@pydantic.with_config({'alias_generator': to_camel})
class TrustVerificationResponse(PebblingProtocolBaseModel):
    """Success response for trust verification."""
    
    id: UUID
    jsonrpc: Literal['2.0'] = '2.0'
    result: Task


###############################################################################################
#######################################   Requests and responses   ############################
###############################################################################################

SendMessageRequest = JSONRPCRequest[Literal['message/send'], MessageSendParams]
"""A JSON RPC request to send a message."""

SendMessageResponse = JSONRPCResponse[Union[Task, Message], JSONRPCError[Any, Any]]
"""A JSON RPC response to send a message."""

StreamMessageRequest = JSONRPCRequest[Literal['message/stream'], MessageSendParams]
"""A JSON RPC request to stream a message."""

GetTaskRequest = JSONRPCRequest[Literal['tasks/get'], TaskQueryParams]
"""A JSON RPC request to get a task."""

GetTaskResponse = JSONRPCResponse[Task, TaskNotFoundError]
"""A JSON RPC response to get a task."""

CancelTaskRequest = JSONRPCRequest[Literal['tasks/cancel'], TaskIdParams]
"""A JSON RPC request to cancel a task."""

CancelTaskResponse = JSONRPCResponse[Task, Union[TaskNotCancelableError, TaskNotFoundError]]
"""A JSON RPC response to cancel a task."""

SetTaskPushNotificationRequest = JSONRPCRequest[Literal['tasks/pushNotification/set'], TaskPushNotificationConfig]
"""A JSON RPC request to set a task push notification."""

SetTaskPushNotificationResponse = JSONRPCResponse[TaskPushNotificationConfig, PushNotificationNotSupportedError]
"""A JSON RPC response to set a task push notification."""

GetTaskPushNotificationRequest = JSONRPCRequest[Literal['tasks/pushNotification/get'], TaskIdParams]
"""A JSON RPC request to get a task push notification."""

GetTaskPushNotificationResponse = JSONRPCResponse[TaskPushNotificationConfig, PushNotificationNotSupportedError]
"""A JSON RPC response to get a task push notification."""

ResubscribeTaskRequest = JSONRPCRequest[Literal['tasks/resubscribe'], TaskIdParams]
"""A JSON RPC request to resubscribe to a task."""

ListTaskPushNotificationConfigRequest = JSONRPCRequest[
    Literal['tasks/pushNotificationConfig/list'], ListTaskPushNotificationConfigParams
]
"""A JSON RPC request to list task push notification configs."""

DeleteTaskPushNotificationConfigRequest = JSONRPCRequest[
    Literal['tasks/pushNotificationConfig/delete'], DeleteTaskPushNotificationConfigParams
]
"""A JSON RPC request to delete a task push notification config."""

DeleteTaskPushNotificationConfigResponse = JSONRPCResponse[TaskPushNotificationConfig, PushNotificationNotSupportedError]
"""A JSON RPC response to delete a task push notification config."""


# Union types for requests and responses
class JSONRPCResponse(
    RootModel[
        JSONRPCErrorResponse
        | SendMessageSuccessResponse
        | SendStreamingMessageSuccessResponse
        | GetTaskSuccessResponse
        | CancelTaskSuccessResponse
        | TrustVerificationResponse
    ]
):
    """Union type for all JSON-RPC responses."""
    
    root: (
        JSONRPCErrorResponse
        | SendMessageSuccessResponse
        | SendStreamingMessageSuccessResponse
        | GetTaskSuccessResponse
        | CancelTaskSuccessResponse
        | TrustVerificationResponse
    )


class SendMessageResponse(
    RootModel[JSONRPCErrorResponse | SendMessageSuccessResponse]
):
    """Union type for send message responses."""
    
    root: JSONRPCErrorResponse | SendMessageSuccessResponse


class SendStreamingMessageResponse(
    RootModel[JSONRPCErrorResponse | SendStreamingMessageSuccessResponse]
):
    """Union type for streaming message responses."""
    
    root: JSONRPCErrorResponse | SendStreamingMessageSuccessResponse

PebblingRequest = Annotated[
    Union[
        SendMessageRequest,
        StreamMessageRequest,
        GetTaskRequest,
        CancelTaskRequest,
        SetTaskPushNotificationRequest,
        GetTaskPushNotificationRequest,
        ResubscribeTaskRequest,
        ListTaskPushNotificationConfigRequest,
        DeleteTaskPushNotificationConfigRequest,
    Discriminator('method'),
]


PebblingRequest = 
    RootModel[
        SendMessageRequest
        | SendStreamingMessageRequest
        | GetTaskRequest
        | CancelTaskRequest
        | TaskResubscriptionRequest
        | TrustVerificationRequest
    ]
):
    """Union type for all Pebbling requests."""
    
    root: (
        SendMessageRequest
        | SendStreamingMessageRequest
        | GetTaskRequest
        | CancelTaskRequest
        | TaskResubscriptionRequest
        | TrustVerificationRequest
    )
    """A2A supported request types"""

#-----------------------------------------------------------------------------
# Lets handle Security
#-----------------------------------------------------------------------------

class AgentSecurity(PebblingProtocolBaseModel):
    """Security configuration for agents in the Pebbling framework."""
    
    # DID-based security settings
    challenge_expiration_seconds: int = Field(
        300, 
        description="Seconds until a challenge expires for DID-based verification"
    )
    require_challenge_response: bool = Field(
        True, 
        description="Whether to require challenge-response verification for agent communication"
    )
    signature_algorithm: str = Field(
        "Ed25519", 
        description="Algorithm used for digital signatures"
    )
    pki_dir: Optional[str] = Field(
        None, 
        description="Path where security keys are stored"
    )
    
    # Server security settings
    endpoint_type: str = Field(
        "json-rpc", 
        description="Type of endpoint (json-rpc, mlts, or http)"
    )
    verify_requests: bool = Field(
        True, 
        description="Whether to verify incoming requests"
    )
    
    # Certificate settings
    cert_dir: Optional[str] = Field(
        None, 
        description="Path to certificate file"
    )
    certificate_authority: Optional[str] = Field(
        None, 
        description="Type of certificate authority (self-signed, letsencrypt, sheldon)"
    )
    
    # Policies
    allow_anonymous: bool = Field(
        False, 
        description="Whether to allow anonymous access"
    )

#-----------------------------------------------------------------------------
# Lets handle Trust
#-----------------------------------------------------------------------------

class TrustLevel(str, Enum):
    """Trust levels for operations and permissions."""
    
    ADMIN = "admin"           # Admin operations, minimal risk
    ANALYST = "analyst"     # Standard operations
    AUDITOR = "auditor"         # Sensitive operations
    EDITOR = "editor"         # Edit operations, moderate risk
    GUEST = "guest"           # Limited access, read-only operations
    MANAGER = "manager"       # Management operations, elevated permissions
    OPERATOR = "operator"     # System operations, moderate risk
    SUPER_ADMIN = "super_admin" # Highest level access, all operations permitted
    SUPPORT = "support"       # Support operations, troubleshooting access
    VIEWER = "viewer"         # View-only access, minimal permissions

class IdentityProvider(str, Enum):
    """Supported identity providers."""
    
    KEYCLOAK = "keycloak"
    AZURE_AD = "azure_ad"
    OKTA = "okta"
    AUTH0 = "auth0"
    CUSTOM = "custom"

class KeycloakRole(PebblingProtocolBaseModel):
    """Keycloak role model."""
    role_id: UUID = Field(..., description="Role ID from Keycloak IAM.")
    role_name: str = Field(..., description="Human-readable role name.")
    permissions: List[str] = Field(default_factory=list, description="Specific permissions tied to this role.")
    trust_level: TrustLevel = Field(TrustLevel.GUEST, description="Default trust level for this role")
    realm_name: str = Field(..., description="The Keycloak realm this role belongs to.")
    
    # For integrations with other identity providers
    external_mappings: Optional[Dict[str, str]] = Field(
        None, 
        description="Mappings to equivalent roles in other identity systems"
    )
    
    # For detailed permission control
    operation_permissions: Optional[Dict[str, TrustLevel]] = Field(
        None,
        description="Operation-specific trust requirements, e.g., {'update_customer': 'high'}"
    )

class AgentTrust(PebblingProtocolBaseModel):
    """Trust configuration for an agent."""
    identity_provider: IdentityProvider = Field(..., description="Identity provider used for authentication")
    inherited_roles: List[KeycloakRole] = Field(
        default_factory=list, 
        description="Roles inherited from the agent's creator"
    )
    certificate: Optional[str] = Field(None, description="Agent's security certificate for verification")
    certificate_fingerprint: Optional[str] = Field(None, description="Fingerprint of the agent's certificate")
    creator_id: Union[UUID, int, str] = Field(..., description="ID of the user who created this agent")
    creation_timestamp: int = Field(..., description="UNIX timestamp of agent creation")
    trust_verification_required: bool = Field(True, description="Whether trust verification is required")
    allowed_operations: Dict[str, TrustLevel] = Field(
        default_factory=dict,
        description="Operations this agent is allowed to perform with required trust levels"
    )

#-----------------------------------------------------------------------------
# Agent 
#-----------------------------------------------------------------------------

class AgentIdentity(PebblingProtocolBaseModel):
    """Agent identity configuration with DID and other identifiers."""
    
    did: Optional[str] = Field(None, description="Agent DID string.")
    did_document: Optional[Dict[str, Any]] = Field(None, description="Agent DID document for decentralized identity.")
    agentdns_url: Optional[str] = Field(None, description="Agent DNS-based identity URL (agentdns.ai).")
    endpoint: Optional[str] = Field(None, description="Secure mTLS agent endpoint.")
    public_key: Optional[str] = Field(None, description="Agent's public key for mTLS.")
    csr: Optional[str] = Field(None, description="Agent's Certificate Signing Request.")
    

@pydantic.with_config({'alias_generator': to_camel})
class AgentSkill(PebblingProtocolBaseModel):
    """Represents a distinct capability or function that an agent can perform."""
    
    id: Required[UUID]
    description: NotRequired[str]
    examples: NotRequired[list[str]]
    input_modes: NotRequired[list[str]]
    name: Required[str]
    output_modes: NotRequired[list[str]]
    tags: NotRequired[list[str]]

@pydantic.with_config({'alias_generator': to_camel})
class AgentExtension(PebblingProtocolBaseModel):
    """A declaration of a protocol extension supported by an Agent."""
    
    description: NotRequired[str]
    params: NotRequired[dict[str, Any]]
    required: Required[bool]
    uri: Required[str]


@pydantic.with_config({'alias_generator': to_camel})
class AgentCapabilities(PebblingProtocolBaseModel):
    """Defines optional capabilities supported by an agent."""
    
    extensions: NotRequired[list[AgentExtension]]
    push_notifications: NotRequired[bool]
    state_transition_history: NotRequired[bool]
    streaming: NotRequired[bool]


class AgentManifest(PebblingProtocolBaseModel):
    """Complete agent manifest with identity and capabilities."""
    
    id: Required[UUID] = Field(
        ..., 
        description="The unique identifier of the agent", 
        examples=["123e4567-e89b-12d3-a456-426614174000"]
    )
    name: str = Field(
        ..., 
        description="The name of the agent", 
        examples=["Japanese Restaurant Reviewer Agent"]
    )
    description: str | None = Field(None, description="Description of the agent")
    user_id: Optional[Union[UUID, int, str]] = Field(None, description="user")

    # Trust
    trust_config: Optional[AgentTrust] = Field(
        None, 
        description="Trust configuration and inherited permissions"
    )

    capabilities: Optional[AgentCapabilities] = Field(
        None, 
        description="Optional capabilities supported by the agent"
    )
    skill: Optional[AgentSkill] = Field(
        None, 
        description="Optional skill supported by the agent"
    )

    instance: Optional[Any] = Field(
        None, 
        description="The agent/team/workflow/mcp instance"
    )
    
    # Configuration
    num_history_sessions: Optional[int] = None
    storage: Optional[Dict[str, Any]] = None
    context: Optional[Dict[str, Any]] = None
    extra_data: Optional[Dict[str, Any]] = None
    
    # Debug settings
    debug_mode: bool = False
    debug_level: Literal[1, 2] = 1 # 1 = Basic, 2 = Detailed
    
    # Monitoring
    monitoring: bool = False
    telemetry: bool = True

    # Security
    security: Optional[AgentSecurity] = Field(
        None, 
        description="Security configuration for the agent"
    )

    # Identity
    identity: Optional[AgentIdentity] = Field(
        None, 
        description="Identity configuration for the agent"
    )
    
    # Versioning
    version: str = Field(..., examples=['1.0.0'])


#-----------------------------------------------------------------------------
# Pebbling Agent Adapter Types
#-----------------------------------------------------------------------------

class PebblingMessage:
    """Wrapper class for protocol messages in AgentAdapter functions."""
    
    def __init__(self, content: str, role: str = "user", metadata: Optional[Dict[str, Any]] = None):
        """
        Initialize a PebblingMessage.
        
        Args:
            content: The message content
            role: The role of the message sender (default: "user")
            metadata: Optional metadata dictionary
        """
        self.content = content
        self.role = role
        self.metadata = metadata or {}
    
    def to_protocol_message(self) -> Message:
        """Convert to protocol Message format."""
        from uuid import uuid4
        
        return Message(
            contextId=uuid4(),
            messageId=uuid4(),
            role=Role(self.role),
            parts=[TextPart(text=self.content)],
            metadata=self.metadata
        )


class PebblingContext:
    """Context wrapper for agent functions providing execution context."""
    
    def __init__(self, 
                 task_id: UUID = None,
                 session_id: UUID = None,
                 metadata: UUID = None,
                 user_id: UUID = None):
        """
        Initialize PebblingContext.
        
        Args:
            task_id: Current task identifier
            session_id: Current session identifier  
            metadata: Additional context metadata
            user_id: User identifier for the current context
        """
        self.task_id = task_id
        self.session_id = session_id
        self.metadata = metadata or {}
        self.user_id = user_id
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get a value from the context metadata."""
        return self.metadata.get(key, default)
    
    def set(self, key: str, value: Any) -> None:
        """Set a value in the context metadata."""
        self.metadata[key] = value