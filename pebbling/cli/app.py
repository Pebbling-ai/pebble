"""Pebble CLI - Command-line interface for managing Pebble agents.

This module provides the main CLI commands for initializing and managing
Pebble agents in a project. It handles project setup, configuration, and
authentication management.
"""

import importlib.util
import json
import subprocess
import sys
from pathlib import Path
from typing import Iterable

import typer
from pydantic import BaseModel, ValidationError
from rich.console import Console
from rich.panel import Panel

from .templates import HELLO_WORLD_AGENT_TEMPLATE


class PebbleUserCredentials(BaseModel):
    """Pydantic model for storing Pebble user authentication credentials.

    Attributes:
        email: User's email address for Pebble authentication.
        api_key: API key for authenticating with Pebble services.
    """
    email: str
    api_key: str


class PebbleConfig(BaseModel):
    """Pydantic model for Pebble configuration.

    Attributes:
        config: Path to the config file.
        auth: Path to the credentials file, or None if not set.
        agent_entrypoint: Path to the agent entrypoint file.
    """
    config: str
    auth: str | None
    agent_entrypoint: str


app = typer.Typer(help="Pebble CLI")
console = Console()

# Constants for common messages and prompts
CONFIG_DIR_ERROR = "[bold red]❌ Config directory {} does not exist. Run 'pebble init' first.[/bold red]"
CONFIG_FILE_ERROR = "[bold red]❌ Config file {} does not exist. Run 'pebble init' first.[/bold red]"
INVALID_CONFIG_ERROR = "[bold red]❌ Invalid config structure: {}[/bold red]"
AUTH_PATH_NULL_ERROR = "[bold red]❌ Auth path is null in config. Run 'pebble auth' with authentication.[/bold red]"
CREDENTIALS_FILE_ERROR = "[bold red]❌ Credentials file {} does not exist. Run 'pebble auth' with authentication.[/bold red]"
PEBBLE_INSTALLED_SUCCESS = "[bold green]✅ Pebble installed successfully![/bold green]"
PEBBLE_INIT_SUCCESS = "[bold green]✅ Pebble initialized successfully![/bold green]"
LAUNCH_COMPLETED = "[bold green]🚀 Launch completed![/bold green]"
AUTH_SUCCESS = "[bold green]✅ Authentication credentials saved![/bold green]"
PEBBLE_RULES_EXIST = "[yellow]ℹ️  Pebble rules already exist in .gitignore - skipping update[/yellow]"
DIRECTORY_EXISTS_ERROR = "[bold red]❌ Directory {} already exists[/bold red]"
FILE_EXISTS_ERROR = "[bold red]❌ File for agent {} already exists[/bold red]"
UNSUPPORTED_DIRECTORY_WARNING = "[yellow]⚠️  Directory '{}' not supported. Only 'hibiscus' is supported.[/yellow]"
UNSUPPORTED_CA_WARNING = "[yellow]⚠️  CA '{}' not supported. Only 'sheldon' is supported.[/yellow]"
EXISTING_CREDENTIALS_WARNING = "[yellow]⚠️  Existing credentials found. This will overwrite them.[/yellow]"
PEBBLE_NOT_FOUND_WARNING = "[bold yellow]⚠️ Pebble package not found. Installing...[/bold yellow]"
INSTALL_FAILED_ERROR = "[bold red]❌ Failed to install with {}. Please install manually.[/bold red]"
WELCOME_MESSAGE = "\n[bold cyan]🐧 Welcome to Pebble! Let's set up your agent[/bold cyan]\n"
CONFIG_DIR_PROMPT = "📁 Config directory"
AGENT_FILE_PROMPT = "🤖 Agent file"
CONFIGURE_AUTH_PROMPT = "🔐 Configure authentication?"
EMAIL_PROMPT = "📧 Email"
API_KEY_PROMPT = "🔑 API Key"
CONTINUE_PROMPT = "Continue?"


def mock_register_hibiscus(directory: str) -> None:
    """Mock function to register a directory in hibiscus registry."""
    console.print(f"[green]✅ Mock: Registered {directory} in hibiscus registry[/green]")


def mock_get_sheldon_cert() -> None:
    """Mock function to get certificate from sheldon CA."""
    console.print("[green]✅ Mock: Obtained certificate from sheldon CA[/green]")


def _short_panel(title: str, body: str, style: str = "bold blue") -> None:
    """Display a formatted panel with a title and body text.

    Args:
        title: The title to display at the top of the panel.
        body: The main content to display inside the panel.
        style: Rich style string for panel formatting (default: "bold blue").
    """
    console.print(Panel.fit(body, title=title, style=style))


def ensure_gitignore_rules(project_root: Path, filepaths: Iterable[str]) -> None:
    """Ensure specified file paths are added to the project's .gitignore file.

    This function checks if a Pebble section exists in the .gitignore file
    and adds the specified filepaths if the section doesn't already exist.
    The function prevents duplicate sections from being created.

    Args:
        project_root: The root directory of the project containing .gitignore.
        filepaths: An iterable of file paths to add to .gitignore.

    Note:
        If the Pebble section already exists in .gitignore, no changes are made.
    """
    section_header = "# pebble autogenerated rules"
    gitignore_path = project_root / ".gitignore"

    file_text = ""
    if gitignore_path.exists():
        file_text = gitignore_path.read_text(encoding="utf-8")

    if section_header in file_text:
        console.print(PEBBLE_RULES_EXIST)
        return

    block_lines = [section_header] + [filepath for filepath in filepaths]
    block = "\n".join(block_lines).strip() + "\n"

    with gitignore_path.open("a", encoding="utf-8") as file:
        if file_text and not file_text.endswith("\n"):
            file.write("\n")

        file.write(block)


def check_directory_exists(path: Path, error_msg: str) -> None:
    """Check if a directory exists, print error and abort if not."""
    if not path.exists():
        console.print(error_msg.format(path))
        raise typer.Abort()


def load_and_validate_config(config_file: Path) -> PebbleConfig:
    """Load and validate config from JSON file."""
    with open(config_file, "r", encoding="utf-8") as f:
        config_data = json.load(f)
    try:
        config = PebbleConfig(**config_data)
    except ValidationError as e:
        console.print(INVALID_CONFIG_ERROR.format(e))
        raise typer.Abort()
    return config


def write_json_file(file_path: Path, data: dict) -> None:
    """Write dictionary data to JSON file."""
    file_path.write_text(json.dumps(data))


def prompt_credentials() -> PebbleUserCredentials:
    """Prompt user for email and API key, return credentials."""
    email = typer.prompt(EMAIL_PROMPT)
    api_key = typer.prompt(API_KEY_PROMPT, hide_input=True)
    return PebbleUserCredentials(email=email, api_key=api_key)


def check_directory_not_exists(path: Path, error_msg: str) -> None:
    """Check if a directory does not exist, print error and abort if it does."""
    if path.exists():
        console.print(error_msg.format(path))
        raise typer.Abort()


def check_file_not_exists(path: Path, error_msg: str) -> None:
    """Check if a file does not exist, print error and abort if it does."""
    if path.exists():
        console.print(error_msg.format(path))
        raise typer.Abort()


def check_file_exists(path: Path, error_msg: str) -> None:
    """Check if a file exists, print error and abort if not."""
    if not path.exists():
        console.print(error_msg.format(path))
        raise typer.Abort()


@app.command()
def init(
    colony: str = typer.Option(".pebble", "--config-dir", help="Pebble config directory"),
    nest: str = typer.Option("pebble_agent.py", "--agent-entry", help="File for your agent"),
    interactive: bool = typer.Option(True, "--yes", help="Use defaults; no prompts"),
):
    """Initialize Pebble in this project."""

    # Check if pebble is installed
    if importlib.util.find_spec("pebble") is None:
        console.print(PEBBLE_NOT_FOUND_WARNING)
        use_uv = (Path.cwd() / "uv.lock").exists() or (Path.cwd() / "pyproject.toml").exists()
        command = ["uv", "add", "pebble"] if use_uv else [sys.executable, "-m", "pip", "install", "pebble"]
        tool_name = "uv" if use_uv else "pip"
        try:
            subprocess.run(command, check=True)
            console.print(PEBBLE_INSTALLED_SUCCESS)
        except subprocess.CalledProcessError:
            console.print(INSTALL_FAILED_ERROR.format(tool_name))

    credentials: PebbleUserCredentials | None = None
    match interactive:
        case False:
            pass
        case True:
            console.print(WELCOME_MESSAGE)

            colony = typer.prompt(CONFIG_DIR_PROMPT, default=colony)
            nest = typer.prompt(AGENT_FILE_PROMPT, default=nest)

            setup_auth = typer.confirm(CONFIGURE_AUTH_PROMPT, default=False)
            if setup_auth:
                credentials = prompt_credentials()

    colony_directory = Path.cwd() / colony
    check_directory_not_exists(colony_directory, DIRECTORY_EXISTS_ERROR)

    colony_directory.mkdir()
    nest_file = Path.cwd() / nest
    check_file_not_exists(nest_file, FILE_EXISTS_ERROR)

    nest_file.write_text(HELLO_WORLD_AGENT_TEMPLATE)

    credentials_json_file = colony_directory / "credentials.json"
    if credentials is not None:
        credentials_json_file.touch()
        write_json_file(credentials_json_file, credentials.model_dump())
        ensure_gitignore_rules(Path.cwd(), [str(credentials_json_file.relative_to(Path.cwd()))])

    config_file = colony_directory / "config.json"
    config_file.touch()

    project_root = Path.cwd()
    config_data = {
        "config": str(config_file.relative_to(project_root)),
        "auth": str(credentials_json_file.relative_to(project_root)) if credentials else None,
        "agent_entrypoint": str(nest_file.relative_to(project_root)),
    }
    write_json_file(config_file, config_data)

    _short_panel(
        PEBBLE_INIT_SUCCESS,
        "[bold]🚀 Ready! Next step: [cyan]`pebble launch`[/cyan][/bold]",
        style="bold green",
    )


@app.command()
def launch(
    directory: str = typer.Option(None, "--directory", help="Directory to register (e.g., hibiscus)"),
    ca: str = typer.Option(None, "--ca", help="CA to get certificate from (e.g., sheldon)"),
    colony: str = typer.Option(".pebble", "--config-dir", help="Pebble config directory"),
):
    """Launch Pebble agent with optional directory registration and CA certificate."""
    colony_directory = Path.cwd() / colony

    # 1. Check if .pebble directory exists
    check_directory_exists(colony_directory, CONFIG_DIR_ERROR)

    config_file = colony_directory / "config.json"

    # 2. Ensure config file exists and has correct structure
    check_file_exists(config_file, CONFIG_FILE_ERROR)

    config = load_and_validate_config(config_file)

    # 3. Credentials only checked if directory or ca is passed
    credentials = None
    if directory or ca:
        if config.auth is None:
            console.print(AUTH_PATH_NULL_ERROR)
            raise typer.Abort()
        credentials_file = colony_directory / config.auth
        check_file_exists(credentials_file, CREDENTIALS_FILE_ERROR)
        with open(credentials_file, "r", encoding="utf-8") as f:
            creds = json.load(f)
        credentials = PebbleUserCredentials(**creds)

    # Handle directory registration
    if directory == "hibiscus":
        mock_register_hibiscus(directory)
    elif directory is not None:
        console.print(UNSUPPORTED_DIRECTORY_WARNING.format(directory))

    # Handle CA certificate
    if ca == "sheldon":
        mock_get_sheldon_cert()
    elif ca is not None:
        console.print(UNSUPPORTED_CA_WARNING.format(ca))

    console.print(LAUNCH_COMPLETED)


@app.command()
def auth(
    colony: str = typer.Option(".pebble", "--config-dir", help="Pebble config directory"),
):
    """Authenticate with Pebble by providing email and API key."""
    colony_directory = Path.cwd() / colony

    # Check if colony directory exists
    check_directory_exists(colony_directory, CONFIG_DIR_ERROR)

    config_file = colony_directory / "config.json"

    # Check if config file exists
    check_file_exists(config_file, CONFIG_FILE_ERROR)

    # Load and validate config
    config = load_and_validate_config(config_file)

    # Check if auth already exists
    if config.auth is not None:
        console.print(EXISTING_CREDENTIALS_WARNING)
        if not typer.confirm(CONTINUE_PROMPT, default=False):
            raise typer.Abort()

    # Prompt for credentials
    credentials = prompt_credentials()

    # Write credentials
    credentials_file = colony_directory / "credentials.json"
    write_json_file(credentials_file, credentials.model_dump())
    ensure_gitignore_rules(Path.cwd(), [str(credentials_file.relative_to(Path.cwd()))])

    # Update config if auth was None
    if config.auth is None:
        config.auth = str(credentials_file.relative_to(Path.cwd()))
        write_json_file(config_file, config.model_dump())

    console.print(AUTH_SUCCESS)


if __name__ == "__main__":
    app()
